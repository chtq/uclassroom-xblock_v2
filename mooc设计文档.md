mooc平台设计说明书
1 背景
   一直以来，相对于传统的教学模式和教学方法，是否能有新的教学办法能够更好地提高学生的学习动力和效率，是广大的教育工作者和机构所关心的话题。近年来，随着MOOC(Massive Online Open Course)的发展，这种新的模式是以开放和共享为教学思想，使用视频为教学方式，具有直观和信息量大等特点，并且加强了学生与媒体的交互，一定程度上降低了学生的学习难度，而且在视频中还穿插练习题，一方面利于学生加深理解，另一方面也提高了学生的学习体验。MOOC比较于传统的教学模式和方法，能使更多的人有机会获得优良的教学资源而且能进一步提高学习的兴趣和灵活的安排时间，越来越受到大家的关注。特别是对于理工类学生的实验课程，其主要目的是通过理论和实践相结合，有效的培养和提高学生的实际动手和解决问题的能力。但是，传统的实验课程无法满足大规模的硬件资源要求而且需要占用学生大量的时间在实验环境部署上使得学生无法专注于课程内容，同时老师也要花费很多的时间在作业批改上。所以，本文基于MOOC利用docker，git等相关技术设计一个让学生可以在线学习、做题、做实验和自动批改作业的平台。
2 系统总体介绍
    本系统运行在4台ubuntu12.04 64位系统虚拟机器上，分别运行open edx、docker、gitlab、视频服务、gitbook网页服务和mongo数据服务，自动测试autotest可作为一个相对独立的模块单独部署在另外的机器上。整个系统的主要业务流程分为三大部分：用户在虚拟环境进行实验；用户web实时交互、autotest自动测试评分。
    用户在虚拟环境进行实验主要过程是，首先管理员或者老师在后台创建实验模板，发布实验镜像，然后学生使用本地浏览器访问网站，注册帐号并登录，申请docker虚拟资源；资源控制器负责接收请求并分配相应的资源，创建镜像运行；用户可通过SSH、VNC 或者是我们提供的Web Terminal连接到docker容器中编写代码进行实验，完成作业后提交push到Git 服务器上。
    用户web实时交互的大概流程是2个用户首先通过ICE建立连接，然后通过Socket.IO进行消息转态传递，在同一个房间共享屏幕和相互通话。
    autotest实际上是一个运行在服务器上的ruby脚本，当监听到用户的Git 仓库的代码有新的commit提交信息， 会自动获取fetch最新代码并执行自动编译、测试、评分，并将执行结果写入数据库；这样当用户进行查询，可以获取到所提交代码的评分和测试结果，而且还能查到以前commit的测试结果。
3 基本概念以及技术
3.1 open edx 
    Open edX是由麻省理工学院和哈佛大学创建的，斯坦福大学、谷歌和 45 所国际大学提供支持的颠覆性技术教学平台。2013年6月，edx的创始者开放了源码，这意味着任何的开发人员都可以获取edx源码，搭建自己的edx平台和实现功能定制。open edx服务后端主要是用过python实现，在web应用层使用Django框架的Mako模板开发。前端web页面显示主要基于javascript编写，也有一些用coffeescript实现，CSS代码使用sass和bourbon框架编写。open edx是由多个组件组成，主要包括LMS（学习管理系统）、cms（内容管理系统）、CS Comments Service、Xblocks、Xqueue Server、Xserver、edx-ora、edinsights等。open edx具有很好的扩展性，扩展办法包括Xblocks、LTI、Jsinput、自定义HTML等。
3.2 Docker
    Docker是Docker公司用Go语言开发的遵从Apache2.0的开源应用容器引擎，能够让开发人员将任何的应用以及依赖打包到一个容器中，然后发布到任何 Linux 机器中。各个容器是完全使用沙箱机制，相互之间没有任何接口，而且几乎没有性能开销，可以很容易地在机器和数据中心部署运行。它是一个轻量级的虚拟解决方案，Docker容器和普通的虚拟机镜像相比，最大的特点是它没有操作系统内核。普通虚拟机需要将整个操作系统运行在虚拟的硬件平台上面并提供完全的运行环境给应用程序运行，但是Docker则是宿主平台上直接加载应用程序运行。Docker包含三个基本组件镜像、容器、注册服务器。Docker容器实际上是在系统底层通过LXC启动一个Linux Container，通过cgroup等机制对不同的容器进行隔离、权限管理和资源分配。使得每个容器拥有自己独立的资源、pID进程、文件系统、内网和主机名等。除了LXC，Docker另外一个核心思想AFUS，它是一个UnionFS将不同目录挂在到同一个虚拟文件系统下的文件系统。Docker镜像使用分层的思想，能够最大化的重用镜像，加快运行速度，减少运行环境构造时间和占用的空间，基于分层思想，一个镜像可以运行在另外一个镜像的基础上，这些镜像又AFUS文件系统加载合并到统一路径中，以只读方式存在，最后在加载一层可写的就形成一个容器，每个容器以copy on write方式维护自己的数据。
3.3 WebRTC
    每个用户或者学生都是处于各自的内网中，没有独立的公网IP地址，两个用户之间进行实时通过就必须解决NAT穿透问题。我们平台使用的是WebRTC技术，它是一个支持网页浏览器进行实时语音对话或视频对话的技术。WebRTC架构组件包括：Web API、WebRTC Native C++ API、音频引擎、视频引擎、传输/会话。
    Web API是面向第三方开发者的WebRTC标准API（Javascript），可分为Network Stream API、 RTCPeerConnection、Peer-to-peer Data API三类，使开发者能够容易地开发出类似于网络视频聊天的web应用。
    WebRTC Native C++ API是本地C++ API层，使浏览器厂商容易实现WebRTC标准的Web API，抽象地对数字信号过程进行处理。
    音频引擎是包含一系列音频多媒体处理的框架，实现从音频采集卡采集音频转换为数字信号到网络传输，使用了iSAC（音频流的宽带和超宽带音频编码器）、iLBC（音频流的窄带语音编解码器）、NetEQ算法（自适应抖动控制算法以及语音包丢失隐藏算法。使其能够快速且高解析度地适应不断变化的网络环境，确保音质优美且缓冲延迟最小）、AEC（回声消除器）、NR（噪声抑制）等技术的解决方案。
    视频引擎含一系列视频处理的整体框架，实现从摄像头采集视频到网络传输再到视频显示，采用了VP8（视频图像编解码器）、Video Jitter Buffer（视频抖动缓冲器，可以降低由于视频抖动和视频信息包丢失带来的不良影响）、Image enhancements（图像质量增强模块，对网络摄像头采集到的图像进行处理，包括明暗度检测、颜色增强、降噪处理等功能）等技术的解决方案。
    传输/会话重用了libjingle库的部分组件实现，实现了无需xmpp协议的P2P连接机制。采用了RTP Stack协议栈、STUN/ICE（可以通过STUN和ICE组件来建立不同类型网络间的呼叫连接，解决内网NAT穿透问题）、Session Management（抽象的会话层，提供会话建立和管理功能，留给应用开发者自定义实现）来实现数据传输和会话控制。
4 各个模块设计
4.1 web界面模块
    web前端主要负责和用户进行交互，处理用户需求和后端服务器之间的消息通信。web界面的展示包括实验介绍信息、课程内容和练习题、实验虚拟环境、实验结果、实时通信等。课程内容和练习题有一个专门的网页服务器进行处理，使用的是gitbook工具开发。课程实验和实时通信使用的是node.js的Express框架和Socket.IO库处理网页和消息服务请求。
    Node.js是基于Google Chrome的V8引擎的javascript运行环境，提供了关于文件操作和网络编程等API，可以方便的搭建响应速度快、易于扩展的网络应用。node.js采用事件驱动、异步编程模式，能够充分利用系统资源，执行代码无须阻塞等待某种操作完成，有限的资源可以用于其他的任务。这样的设计非常适合于后端的网络服务编程。在服务器开发中，并发的请求处理是个大问题，阻塞式的函数会导致资源浪费和时间延迟。nodejs是以单进程、单线程的方式运行，没有多线程的资源占有和上下文切换，面对大规模的http请求nodejs是通过内部单线程高效率的维护事件循环队列处理的。
    Express是一个简洁灵活的node.js web应用框架，它提供一系列强大的特性，容易的创建各种 Web 和移动设备应用；具有丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，使得通过健壮友好的api处理url请求变得快速简单。socket.IO是一个node.js库，包括了客户端的js和服务器端的node.js，它的目标是构建可以在不同浏览器和移动设备上使用的实时应用。它会自动根据浏览器从WebSocket、AJAX长轮询、Iframe流等等各种方式中选择最佳的方式来实现网络实时应用；而且socket.IO还支持room房间相当于命名空间的消息广播，不同的客户端可以在一个room内进行聊天通信，非常的方便灵活。
    gitbook使用node.js开发的一个命令行工具，可以识别Markdown语法格式的文件，并可以生成PDF等格式电子书输出。gitbook也可以生成静态的HTML网页作为简单的静态网站，只需要为它指定README.md和SUMMARY.md两个文件，README.md是书的介绍，SUMMARY.md是书的目录、章节结构。gitbook可以灵活的处理md文件的内容，它提供了plugin（插件）功能能够对每个md内容进行处理，并支持外部的的javascript和css文件嵌入到HTML中，所以开发人员可以很方便按照自己想要的结果开发plugin。
4.2 docker虚拟资源模块
    mooc平台实验部分所需的虚拟环境是由docker提供的，docker负责每个客户的资源分配和存储。这个模块只需要提供一台服务器，在上面安装docker，安装也很简单，通过apt-get命令就可以安装，然后运行 docker  -d  --tlsverify --tlscacert=<ca.pem>  --tlscert=<server-cert.pem>  --tlskey=<server-key.pem> -H=0.0.0.0:2376，这样docker服务端就启动起来了，最后通过一个可用的域名采用https方式就可以进行docker交互。docker对镜像是层次化的存储，所以不需要很大的存储空间就可以分配很多的学生实验容器，能够满足整个平台的需求。
4.3 虚拟资源控制模块
     这个模块是监控整个系统的后台资源的运行状态和接受用户的docker资源申请、使用、删除等工作。学生进行在线实验的dcoker镜像分为三个部分：一是基本的操作系统和需要用到的一下软件镜像；二是老师发布实验所包含的代码、工具记忆文档镜像；三是学生申请虚拟环境所需的个人私钥、公钥、启动脚本镜像。前面说过，dcoker镜像采用的是分层的思想，前面的镜像是下一个镜像的基础，后面的镜像生成只需要很短的时间。而整个过程底层实际上是执行一系列的shell脚本，对上层统一封装提供一组api接口。通过这个模块很方便的把docker容器的状态变化和前台页面的显示联系起来，进行实时状态传递。
4.4 git模块
    这个模块是负责保存学生进行实验的私有代码，只能学生和老师有权限访问，别的学生不能访问，同时需要对外提供web和git两种访问方式。而Gitlab是一个用Ruby on Rails开发的开源项目管理程序，实现一个自托管的Git项目仓库，可以通过WEB界面进行访问公开的或者私人项目。GitLab提供几种管理项目（Project或Repository）权限的方式，向所有人公开、向注册用户公开、向指定人员公开、不公开。它拥有与Github类似的功能，能够浏览源代码，管理版本和注释，并且gitlab提供了丰富的REST接口，所以我们使用gitlab社区版本作为远程git仓库。
4.5 数据库模块
    Mongo DB 是基于分布式文件存储的，由C++语言编写的一种非关系型数据库(NoSql)，很好的实现了面向对象的思想，在Mongo DB中每一条记录都是一个Document对象，按照BSON方式存储。它与传统的关系型数据库相比，它具有操作简单、高性能、易部署、易使用，存储数据非常方便特点。
4.6 autotes模块
    这个模块分为2个部分，都是使用ruby编写的，一是基于ucore实验的自动测试评分部分，二是结果展示部分。自动测试部分从数据库中获得学生id、docker名称、老师的私钥，有了这些信息就可以去远程git仓库下载学生的实验代码，老师有权限访问所有的学生代码，通过分析git log获得每次提交的commit信息，然后对最新一个commit进行编译、测试、评分，最后把相关测试结果和分数通过mongodb保存在数据库中，同时也把每次的测试结果的url连接发送给学生邮箱。结果展示部分就是把每次测试的信息通过网页的方式显示出来，学生通过邮箱的url连接就可以查看，也可以在edx的xblock中查看。而且学生的作业是私有的，其他的学生无权查看别的学生的测试结果，通过这种方式可以防止获得别的学生url，实现了私有性。
4.7 P2P通信模块
    ICE全称叫交互式连接建立（Interactive Connectivity Establishment）一种综合性的NAT穿透技术，主要负责与用户端浏览器交互公网信息，遵循STUN（Session Traversal Utilities for NAT）或TURN（Traversal Using Relays around NAT）等协议，响应内网客户端发出的请求，并将内网客户端的公网IP 地址与端口等信息以会话描述协议（Session Description Protocol，SDP）类型的消息返回给客户端。对于内网的2个用户节点进行通信的基本流程如下：⑴节点1 首先向ICE 服务器发出请求；⑵ICE 服务器收到请求后，将节点1 的公网信息返回给节点1；⑶节点1 将自身公网信息发送给消息服务器；⑷消息服务器将接收到节点1 的公网信息转发给节点2；⑸节点2 向ICE 发出请求；⑹ICE 服务器收到请求后，将节点2 的公网信息返回给节点2；⑺节点2 将自身的公网信息发送给消息服务器；⑻消息服务器将节点2的公网信息转发给节点1，至此，节点1、节点2均得到了双方的公网信息；⑼节点1可以根据节点2的公网信息直接发起连接。如果P2P双方直接通信失败，则ICE会使用TURN服务器作为中间节点转发数据。
5 未来扩展和考虑

